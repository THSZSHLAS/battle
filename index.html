<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ±¤è‡£å…¨èƒ½ç›‘ç£ç³»ç»Ÿ V5.1</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body { margin: 0; padding: 0; background-color: #1a1a1a; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: white; overflow: hidden; user-select: none; }

        /* === æ ¸å¿ƒè§†è§‰ UI === */
        #visual-ring { width: 200px; height: 200px; border: 8px solid #444; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.4s; position: relative; background: rgba(0,0,0,0.2); z-index: 5; }
        body.studying #visual-ring { border-color: #2ecc71; box-shadow: 0 0 40px rgba(46, 204, 113, 0.4); animation: breathe 3s infinite; }
        body.warning #visual-ring { border-color: #e74c3c; background-color: rgba(231, 76, 60, 0.15); box-shadow: 0 0 60px rgba(231, 76, 60, 0.7); transform: scale(1.05); animation: pulse-red 0.5s infinite; }
        
        .icon { font-size: 60px; }
        #status-text { margin-top: 30px; font-size: 20px; font-weight: 400; opacity: 0.9; text-align: center; height: 30px; z-index: 5; }

        /* === ç›‘æ§çª—å£ (ç”»ä¸­ç”») === */
        
        /* å³ä¸Šè§’ï¼šäººè„¸ */
        .cam-box {
            position: absolute; top: 20px; right: 20px;
            width: 200px; height: 150px;
            border: 2px solid #555; border-radius: 10px;
            overflow: hidden; z-index: 10; background: #000;
        }
        video#webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.9; }

        /* å·¦ä¸Šè§’ï¼šå±å¹• (æ–°å¢) */
        .screen-box {
            position: absolute; top: 20px; left: 20px;
            width: 240px; height: 150px; /* å±å¹•å®½ä¸€ç‚¹ */
            border: 2px solid #555; border-radius: 10px;
            overflow: hidden; z-index: 10; background: #000;
            display: flex; flex-direction: column;
        }
        video#screen-video { width: 100%; height: 130px; object-fit: contain; opacity: 1; }
        
        /* å±å¹•æ´»è·ƒåº¦æ¡ */
        #activity-bar-bg { width: 100%; height: 20px; background: #222; position: relative; }
        #activity-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #2ecc71, #f1c40f, #e74c3c); transition: width 0.2s; }
        #activity-text { position: absolute; top: 0; left: 5px; font-size: 10px; line-height: 20px; color: #fff; }

        /* åº•éƒ¨æ§åˆ¶æ  */
        #controls { position: fixed; bottom: 40px; display: flex; gap: 15px; align-items: center; padding: 12px 25px; background: rgba(30,30,30,0.9); border-radius: 40px; z-index: 50; }
        button, select { padding: 10px 20px; border-radius: 20px; border: none; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button:active { transform: scale(0.95); }
        #screen-btn { background: #3498db; color: #fff; }
        #start-btn { background: #2ecc71; color: #fff; }
        #stop-btn { background: #ff4757; color: #fff; display: none; }
        #break-btn { background: #f1c40f; color: #000; display: none; }
        #mode-select { background: #444; color: #fff; }

        /* é®ç½©ä¸æŠ¥å‘Š */
        #countdown-overlay, #report-panel { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; display: none; align-items: center; justify-content: center; flex-direction: column; background: rgba(0,0,0,0.95); }
        #report-panel { background: #222; width: 320px; height: auto; top: 50%; left: 50%; transform: translate(-50%, -50%); border-radius: 20px; padding: 30px; border: 1px solid #444; }
        
        .calib-btn { padding: 15px 30px; margin: 10px; background: #333; color: white; border: 1px solid #555; width: 260px; text-align: left; }
        .calib-btn.done { background: #2ecc71; border-color: #2ecc71; }
        #calib-start-study-btn { background: linear-gradient(135deg, #2ecc71, #27ae60); margin-top: 20px; width: 260px; text-align: center; font-size: 18px; opacity: 0.5; pointer-events: none; }
        #calib-start-study-btn.ready { opacity: 1; pointer-events: auto; }

        .score { font-size: 50px; font-weight: 800; color: #2ecc71; margin: 10px 0; }
        .row { display: flex; justify-content: space-between; width: 100%; margin: 8px 0; color: #ccc; border-bottom: 1px solid #333; padding-bottom: 5px; }

        @keyframes breathe { 0%,100%{opacity:0.8;transform:scale(1);} 50%{opacity:1;transform:scale(1.05);} }
        @keyframes pulse-red { 0%,100%{box-shadow:0 0 0 rgba(231,76,60,0);} 50%{box-shadow:0 0 40px rgba(231,76,60,0.8);} }
    </style>
</head>
<body>

    <div id="visual-ring"><div class="icon" id="status-icon">ğŸ‘ï¸</div></div>
    <div id="status-text">ç³»ç»Ÿåˆå§‹åŒ–...</div>

    <div class="screen-box" id="screen-box-ui" style="visibility: hidden;">
        <video id="screen-video" autoplay playsinline muted></video>
        <div id="activity-bar-bg">
            <div id="activity-bar"></div>
            <div id="activity-text">å±å¹•çƒ­åº¦: 0%</div>
        </div>
    </div>

    <div class="cam-box">
        <video id="webcam" autoplay playsinline muted></video>
    </div>

    <div id="controls">
        <select id="mode-select">
            <option value="easy">å®½æ¾</option>
            <option value="normal" selected>æ ‡å‡†</option>
            <option value="hard">ä¸¥æ ¼</option>
        </select>
        <button id="screen-btn">â‘  æ¥å…¥å±å¹•</button>
        <button id="start-btn" disabled>â‘¡ æ¥å…¥äººè„¸</button>
        <button id="break-btn">ä¼‘æ¯</button>
        <button id="stop-btn">åœæ­¢</button>
    </div>

    <div id="countdown-overlay">
        <h2 style="color:white; margin-bottom:30px;">å§¿æ€æ ¡å‡†</h2>
        <button id="calib-screen-btn" class="calib-btn">â‘  é”å®šâ€œçœ‹å±å¹•â€å§¿åŠ¿</button>
        <button id="calib-book-btn" class="calib-btn">â‘¡ (å¯é€‰) é”å®šâ€œçœ‹ä¹¦â€å§¿åŠ¿</button>
        <button id="calib-start-study-btn" class="calib-btn">å¼€å§‹ç›‘ç£</button>
    </div>

    <div id="report-panel" style="display:none;">
        <h3 style="color:white; margin:0;">ä¸“æ³¨è¯„åˆ†</h3>
        <div class="score" id="final-score">0</div>
        <div class="row"><span>â±ï¸ æ—¶é•¿</span><span id="r-time">0åˆ†</span></div>
        <div class="row"><span>ğŸ‘€ è§†çº¿åç¦»</span><span id="r-distract">0æ¬¡</span></div>
        <div class="row"><span>ğŸ® å±å¹•å¨±ä¹</span><span id="r-screen">0æ¬¡</span></div>
        <div class="row"><span>ğŸ‘» ç¦»å¼€ç”»é¢</span><span id="r-absent">0æ¬¡</span></div>
        <button onclick="location.reload()" style="margin-top:20px; padding:12px; background:#444; color:white; width:100%; border:none; border-radius:20px;">é‡æ–°å¼€å§‹</button>
    </div>

    <script type="module">
        import { FilesetResolver, FaceLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

        const CONFIG = {
            PASSWORD: "8888",
            checkInterval: 1000, 
            
            // é˜ˆå€¼é…ç½®
            threshold: { angle: 0.28, roll: 20 },
            durations: { distractedMs: 3000, absentMs: 5000 },
            
            // å±å¹•çƒ­åº¦ç³»ç»Ÿ (Heat System)
            screen: {
                diffThreshold: 5,   // åªè¦æœ‰ 5 ä¸ªåƒç´ ç‚¹å‰§çƒˆå˜åŒ–å°±ç®—åŠ¨ (æé«˜çµæ•åº¦)
                heatUp: 15,         // åŠ¨ä¸€ä¸‹åŠ  15 çƒ­åº¦
                coolDown: 5,        // æ¯ç§’å†·å´ 5 çƒ­åº¦
                triggerHeat: 80,    // çƒ­åº¦è¶…è¿‡ 80 æŠ¥è­¦
                maxHeat: 100
            },

            score: { base: 60, focusPerSec: 0.015, distractPen: 1.5, screenPen: 5, absentPen: 3 }
        };

        const SPEECH = {
            start: "å…¨æ™¯ç›‘ç£å¯åŠ¨ã€‚",
            focusAgain: ["çŠ¶æ€å›æ¥äº†ã€‚", "ä¿æŒä¸“æ³¨ã€‚", "ç»§ç»­ã€‚"],
            distracted: ["å›æ¥çœ‹ä¹¦ã€‚", "åˆ«ä¹±çœ‹ã€‚", "æ³¨æ„åŠ›ã€‚"],
            posture: ["åç›´ã€‚", "è…°èƒŒæŒºç›´ã€‚"],
            absent: ["äººå‘¢ï¼Ÿ", "å¿«å›æ¥ã€‚"],
            gaming: ["å±å¹•åŠ¨é™å¤ªå¤§äº†ï¼Œåœ¨çœ‹è§†é¢‘å—ï¼Ÿ", "æ£€æµ‹åˆ°å¨±ä¹è¡Œä¸ºï¼Œè¯·åˆ‡å›å­¦ä¹ ã€‚", "åˆ«æ‘¸é±¼äº†ï¼"],
            stop: "ç›‘ç£ç»“æŸã€‚"
        };

        // çŠ¶æ€å˜é‡
        let faceLandmarker = null;
        let isRunning = false;
        let currentState = "IDLE";
        let lastVideoTime = -1;
        let lastCheck = 0;
        let baseScreenPose = null, baseBookPose = null;
        let awayStartTime = null, absentStartTime = null;

        // å±å¹•ç›‘æ§å˜é‡
        let screenStream = null;
        let screenCanvas = document.createElement('canvas');
        let screenCtx = screenCanvas.getContext('2d');
        let lastScreenData = null;
        let screenHeat = 0; // å½“å‰çƒ­åº¦ (0-100)

        // ç»Ÿè®¡
        let stats = { start: 0, distractCount: 0, postureCount: 0, absentCount: 0, screenCount: 0, score: CONFIG.score.base };
        let warnCooldown = 0;

        // å…ƒç´ 
        const els = {
            webcam: document.getElementById('webcam'),
            screenVideo: document.getElementById('screen-video'),
            screenBoxUI: document.getElementById('screen-box-ui'),
            startBtn: document.getElementById('start-btn'),
            screenBtn: document.getElementById('screen-btn'),
            stopBtn: document.getElementById('stop-btn'),
            breakBtn: document.getElementById('break-btn'),
            text: document.getElementById('status-text'),
            icon: document.getElementById('status-icon'),
            modeSelect: document.getElementById('mode-select'),
            overlay: document.getElementById('countdown-overlay'),
            report: document.getElementById('report-panel'),
            actBar: document.getElementById('activity-bar'),
            actText: document.getElementById('activity-text')
        };

        // 1. åˆå§‹åŒ–
        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                    outputFaceBlendshapes: true, runningMode: "VIDEO", numFaces: 1
                });
                els.startBtn.innerText = "â‘¡ æ¥å…¥äººè„¸";
                els.startBtn.disabled = false;
            } catch(e) { console.error(e); }
        }
        init();

        // 2. å±å¹•æ¥å…¥
        els.screenBtn.onclick = async () => {
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "always" }, audio: false });
                els.screenVideo.srcObject = screenStream;
                els.screenBoxUI.style.visibility = 'visible'; // æ˜¾ç¤ºé¢„è§ˆ
                els.screenBtn.innerText = "âœ… å±å¹•å·²æ¥å…¥";
                els.screenBtn.style.background = "#2ecc71";
                screenStream.getVideoTracks()[0].onended = () => location.reload();
            } catch(e) { alert("å¿…é¡»æ¥å…¥å±å¹•æ‰èƒ½å¼€å§‹ã€‚"); }
        };

        // 3. æ‘„åƒå¤´æ¥å…¥
        els.startBtn.onclick = async () => {
            if (!faceLandmarker) return;
            if (!screenStream) { alert("è¯·å…ˆæ¥å…¥å±å¹•ï¼"); return; }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                els.webcam.srcObject = stream;
                els.webcam.onloadeddata = () => els.overlay.style.display = 'flex';
            } catch(e) { alert("æ‘„åƒå¤´æ‰“å¼€å¤±è´¥"); }
        };

        // 4. æ ¡å‡†
        const capturePose = () => {
            const now = performance.now();
            const res = faceLandmarker.detectForVideo(els.webcam, now);
            return (res && res.faceLandmarks.length) ? calculatePose(res.faceLandmarks[0]) : null;
        };
        document.getElementById('calib-screen-btn').onclick = function() {
            const p = capturePose();
            if(p) { baseScreenPose = p; this.classList.add('done'); this.innerText="å·²é”å®š (çœ‹å±å¹•) âœ…"; checkReady(); } else alert("æ²¡çœ‹åˆ°è„¸");
        };
        document.getElementById('calib-book-btn').onclick = function() {
            const p = capturePose();
            if(p) { baseBookPose = p; this.classList.add('done'); this.innerText="å·²é”å®š (çœ‹ä¹¦æœ¬) âœ…"; checkReady(); } else alert("æ²¡çœ‹åˆ°è„¸");
        };
        function checkReady() { if(baseScreenPose || baseBookPose) document.getElementById('calib-start-study-btn').classList.add('ready'); }

        // 5. å¼€å§‹
        document.getElementById('calib-start-study-btn').onclick = () => {
            els.overlay.style.display = 'none';
            els.startBtn.style.display = 'none';
            els.screenBtn.style.display = 'none';
            els.modeSelect.style.display = 'none';
            els.breakBtn.style.display = 'block';
            els.stopBtn.style.display = 'block';
            
            applyMode(els.modeSelect.value);
            stats.start = Date.now();
            isRunning = true;
            updateStatus("studying", "ğŸ“–", "å…¨æ™¯ç›‘ç£ä¸­...");
            speak(SPEECH.start);
            loop();
        };

        // 6. ä¸»å¾ªç¯
        function loop() {
            if (!isRunning) return;
            if (currentState === "BREAK") { requestAnimationFrame(loop); return; }

            const now = Date.now();
            if (now - lastCheck > CONFIG.checkInterval) {
                
                // å¹¶è¡Œæ£€æµ‹
                if(screenStream) analyzeScreen();
                
                if (els.webcam.currentTime > 0) {
                    const res = faceLandmarker.detectForVideo(els.webcam, performance.now());
                    analyzeFace(res);
                }
                
                lastCheck = now;
            }
            requestAnimationFrame(loop);
        }

        // --- å±å¹•çƒ­åº¦ç®—æ³• (Heat System) ---
        function analyzeScreen() {
            // é™é‡‡æ ·
            const w = 128, h = 72; //ç¨å¾®å¤§ä¸€ç‚¹ç‚¹ä»¥é€‚åº”Mac
            screenCanvas.width = w; screenCanvas.height = h;
            screenCtx.drawImage(els.screenVideo, 0, 0, w, h);
            
            const frame = screenCtx.getImageData(0, 0, w, h);
            const data = frame.data;

            if (!lastScreenData) { lastScreenData = data; return; }

            let diffCount = 0;
            // æ­¥é•¿å– 4 (é€åƒç´ æ£€æŸ¥)
            for (let i = 0; i < data.length; i += 4) {
                const diff = Math.abs(data[i] - lastScreenData[i]) + 
                             Math.abs(data[i+1] - lastScreenData[i+1]) + 
                             Math.abs(data[i+2] - lastScreenData[i+2]);
                if (diff > 50) diffCount++;
            }
            lastScreenData = data;

            // çƒ­åº¦è®¡ç®—
            if (diffCount > CONFIG.screen.diffThreshold) {
                screenHeat += CONFIG.screen.heatUp; // åŠ¨äº†ï¼ŒåŠ çƒ­åº¦
            } else {
                screenHeat -= CONFIG.screen.coolDown; // æ²¡åŠ¨ï¼Œæ•£çƒ­
            }
            
            // é™åˆ¶èŒƒå›´
            screenHeat = Math.max(0, Math.min(CONFIG.screen.maxHeat, screenHeat));

            // æ›´æ–° UI æ¡
            els.actBar.style.width = screenHeat + "%";
            els.actText.innerText = "å±å¹•æ´»è·ƒ: " + Math.round(screenHeat) + "%";
            
            // å˜è‰²é¢„è­¦
            if (screenHeat > 50) els.actBar.style.background = "linear-gradient(90deg, #f1c40f, #e74c3c)";
            else els.actBar.style.background = "linear-gradient(90deg, #2ecc71, #f1c40f)";

            // æŠ¥è­¦
            if (screenHeat > CONFIG.screen.triggerHeat) {
                handleWarn("gaming", "ğŸ® å±å¹•åŠ¨é™å¤ªå¤§ï¼");
                if (currentState !== "GAMING") {
                    currentState = "GAMING";
                    stats.screenCount++;
                    stats.score -= CONFIG.score.screenPen;
                }
            } else if (currentState === "GAMING" && screenHeat < 50) {
                // çƒ­åº¦é™ä¸‹æ¥äº†ï¼Œæ¢å¤
                currentState = "FOCUSED";
                updateStatus("studying", "ğŸ“–", "å­¦ä¹ ä¸­...");
            }
        }

        function analyzeFace(results) {
            if(currentState === "GAMING") return; // å±å¹•æŠ¥è­¦ä¼˜å…ˆ

            if (!results.faceLandmarks.length) {
                handleWarn("absent", "ğŸ‘» äººå‘¢ï¼Ÿ");
                if(currentState !== "ABSENT") { stats.absentCount++; stats.score -= CONFIG.score.absentPen; currentState="ABSENT"; }
                return;
            }
            absentStartTime = null;

            const lm = results.faceLandmarks[0];
            const p = calculatePose(lm);
            let ok = false;
            if (baseScreenPose && isClose(p, baseScreenPose)) ok = true;
            if (baseBookPose && isClose(p, baseBookPose)) ok = true;

            if (!ok) {
                if(!awayStartTime) awayStartTime = Date.now();
                if(Date.now() - awayStartTime > CONFIG.durations.distractedMs) {
                    const diffRoll = baseScreenPose ? Math.abs(p.roll - baseScreenPose.roll) : 0;
                    if (diffRoll > CONFIG.threshold.roll) {
                        handleWarn("posture", "ğŸ¦´ åç›´ï¼");
                        if(currentState!=="POSTURE") { stats.postureCount++; stats.score -= CONFIG.score.posturePen; currentState="POSTURE"; }
                    } else {
                        handleWarn("distracted", "ğŸ‘€ åˆ«ä¹±çœ‹");
                        if(currentState!=="DISTRACTED") { stats.distractCount++; stats.score -= CONFIG.score.distractPen; currentState="DISTRACTED"; }
                    }
                } else {
                    updateStatus("studying", "âš ï¸", "è°ƒæ•´ä¸­...");
                }
            } else {
                awayStartTime = null;
                if(currentState !== "FOCUSED") {
                    currentState = "FOCUSED";
                    updateStatus("studying", "ğŸ“–", "å­¦ä¹ ä¸­...");
                    stats.score += CONFIG.score.focusPerSec;
                    speak(pick(SPEECH.focusAgain));
                }
            }
            if(stats.score < 0) stats.score = 0;
            if(stats.score > 100) stats.score = 100;
        }

        // --- å·¥å…· ---
        function calculatePose(lm) {
            const nose=lm[1], left=lm[33], right=lm[263];
            const midX=(left.x+right.x)/2, eyeY=(left.y+right.y)/2;
            return {
                yaw: nose.x - midX,
                pitch: nose.y - eyeY,
                roll: Math.atan2(right.y-left.y, right.x-left.x)*180/Math.PI
            };
        }
        function isClose(curr, base) {
            return Math.abs(curr.yaw-base.yaw)<CONFIG.threshold.angle && 
                   Math.abs(curr.pitch-base.pitch)<CONFIG.threshold.angle &&
                   Math.abs(curr.roll-base.roll)<CONFIG.threshold.roll;
        }
        function handleWarn(type, txt) {
            updateStatus("warning", txt.substring(0,2), txt);
            if(Date.now() > warnCooldown) {
                speak(pick(SPEECH[type]));
                warnCooldown = Date.now() + 5000;
            }
        }
        function updateStatus(cls, icon, txt) {
            document.body.className = cls;
            els.text.innerText = txt;
            els.icon.innerText = icon;
        }
        function applyMode(mode) {
            if(mode === "hard") { CONFIG.threshold.angle=0.15; CONFIG.screen.triggerHeat=60; }
            else if(mode==="easy") { CONFIG.threshold.angle=0.35; CONFIG.screen.triggerHeat=90; }
        }

        els.stopBtn.onclick = () => {
            if (prompt("å¯†ç ï¼š") === CONFIG.PASSWORD) {
                isRunning = false;
                if(screenStream) screenStream.getTracks().forEach(t=>t.stop());
                if(els.webcam.srcObject) els.webcam.srcObject.getTracks().forEach(t=>t.stop());
                
                // ä¿®å¤ï¼šç¡®ä¿æ˜¾ç¤º
                els.report.style.display = 'flex';
                setTimeout(() => els.report.classList.add('show'), 10);
                showReport();
            } else speak("å¯†ç é”™è¯¯");
        };

        function showReport() {
            document.getElementById('r-time').innerText = Math.floor((Date.now()-stats.start)/60000)+"åˆ†";
            document.getElementById('r-distract').innerText = stats.distractCount;
            document.getElementById('r-screen').innerText = stats.screenCount;
            document.getElementById('r-absent').innerText = stats.absentCount;
            document.getElementById('final-score').innerText = Math.round(stats.score);
            speak(SPEECH.stop);
        }

        els.breakBtn.onclick = () => {
            if (currentState === "BREAK") {
                currentState = "FOCUSED"; awayStartTime = null; screenHeat = 0;
                els.breakBtn.innerText = "ä¼‘æ¯"; els.stopBtn.style.display = "block";
                updateStatus("studying", "ğŸ“–", "æ¬¢è¿å›æ¥"); speak(pick(SPEECH.breakEnd));
            } else {
                currentState = "BREAK";
                els.breakBtn.innerText = "ç»“æŸä¼‘æ¯"; els.stopBtn.style.display = "none";
                updateStatus("break", "â˜•", "ä¼‘æ¯ä¸­..."); speak(pick(SPEECH.breakStart));
            }
        };

        const synth = window.speechSynthesis;
        function speak(text) {
            if(!synth) return;
            synth.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = "zh-CN"; u.rate = 1.2;
            synth.speak(u);
        }
        function pick(arr) { return arr[Math.floor(Math.random()*arr.length)]; }
        document.body.addEventListener('click', ()=>{if(synth)synth.speak(new SpeechSynthesisUtterance(" "))}, {once:true});

    </script>
</body>
</html>
