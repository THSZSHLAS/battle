<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ±¤è‡£å…¨æ™¯ç›‘ç£ç³»ç»Ÿ</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body { margin: 0; padding: 0; background-color: #1a1a1a; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: white; overflow: hidden; user-select: none; }

        /* === è§†è§‰ UI === */
        #visual-ring { width: 180px; height: 180px; border: 8px solid #444; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.4s; position: relative; background: rgba(0,0,0,0.2); z-index: 5; }
        
        body.studying #visual-ring { border-color: #2ecc71; box-shadow: 0 0 40px rgba(46, 204, 113, 0.4); animation: breathe 3s infinite; }
        body.warning #visual-ring { border-color: #e74c3c; box-shadow: 0 0 60px rgba(231, 76, 60, 0.7); animation: pulse-red 0.8s infinite; }
        
        .icon { font-size: 50px; }
        #status-text { margin-top: 30px; font-size: 20px; opacity: 0.8; letter-spacing: 1px; text-align: center; height: 30px; }

        /* === ç›‘æ§ç”»é¢å®¹å™¨ (ç”»ä¸­ç”») === */
        .monitor-container {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px;
            z-index: 100;
        }
        
        .preview-box {
            width: 160px; height: 120px;
            background: #000; border: 2px solid #555;
            border-radius: 8px; overflow: hidden;
            position: relative;
            transition: all 0.3s;
        }
        .preview-box:hover { transform: scale(1.5) translateX(-20px) translateY(20px); border-color: #2ecc71; z-index: 101; }
        
        video { width: 100%; height: 100%; object-fit: cover; }
        #webcam { transform: scaleX(-1); } /* é•œåƒäººè„¸ */
        #screen-video { object-fit: contain; } /* å±å¹•å®Œæ•´æ˜¾ç¤º */
        
        .label { position: absolute; bottom: 2px; left: 5px; font-size: 10px; color: rgba(255,255,255,0.7); background: rgba(0,0,0,0.5); padding: 2px 4px; border-radius: 4px; }

        /* åº•éƒ¨æ§åˆ¶ */
        #controls { position: fixed; bottom: 30px; display: flex; gap: 15px; background: rgba(30,30,30,0.9); padding: 15px 30px; border-radius: 40px; z-index: 50; }
        button, select { padding: 10px 20px; border-radius: 20px; border: none; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button:active { transform: scale(0.95); }
        #start-btn { background: #2ecc71; color: white; }
        #screen-btn { background: #3498db; color: white; }
        #stop-btn { background: #ff4757; color: white; display: none; }

        /* æ ¡å‡†é®ç½© */
        #countdown-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; align-items: center; justify-content: center; flex-direction: column; z-index: 200; }
        .calib-btn { padding: 15px 40px; font-size: 18px; background: #333; color: white; border: 1px solid #555; margin: 10px; width: 280px; }
        .calib-btn.done { background: #2ecc71; border-color: #2ecc71; }
        #calib-final-btn { background: linear-gradient(135deg, #2ecc71, #27ae60); margin-top: 30px; opacity: 0.5; pointer-events: none; }
        #calib-final-btn.ready { opacity: 1; pointer-events: auto; }

        /* æŠ¥å‘Š */
        #report-panel { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; padding: 30px; border-radius: 20px; display: none; flex-direction: column; text-align: center; border: 1px solid #444; z-index: 300; width: 300px; }
        .score { font-size: 60px; font-weight: 800; color: #2ecc71; margin: 10px 0; }
        .row { display: flex; justify-content: space-between; margin: 5px 0; color: #ccc; font-size: 14px; }

        @keyframes breathe { 0%,100%{opacity:0.8; transform:scale(1);} 50%{opacity:1; transform:scale(1.05);} }
        @keyframes pulse-red { 0%,100%{box-shadow: 0 0 0 rgba(231,76,60,0);} 50%{box-shadow: 0 0 30px rgba(231,76,60,0.8);} }
    </style>
</head>
<body>

    <div id="visual-ring"><div class="icon" id="status-icon">ğŸ‘ï¸</div></div>
    <div id="status-text">ç³»ç»Ÿåˆå§‹åŒ–...</div>

    <div class="monitor-container">
        <div class="preview-box">
            <video id="webcam" autoplay playsinline muted></video>
            <div class="label">äººè„¸ç›‘æ§</div>
        </div>
        <div class="preview-box" id="screen-box" style="display:none;">
            <video id="screen-video" autoplay playsinline muted></video>
            <div class="label">å±å¹•ç›‘æ§</div>
        </div>
    </div>

    <div id="controls">
        <button id="screen-btn">â‘  æ¥å…¥å±å¹•</button>
        <button id="start-btn" disabled>â‘¡ åŠ è½½äººè„¸æ¨¡å‹...</button>
        <button id="stop-btn">åœæ­¢ (éœ€å¯†ç )</button>
    </div>

    <div id="countdown-overlay">
        <h2 style="color:white; margin-bottom:30px;">å§¿æ€æ ¡å‡†</h2>
        <button id="calib-screen-btn" class="calib-btn">é”å®šâ€œçœ‹å±å¹•â€å§¿åŠ¿</button>
        <button id="calib-book-btn" class="calib-btn">é”å®šâ€œçœ‹ä¹¦æœ¬â€å§¿åŠ¿</button>
        <button id="calib-final-btn" class="calib-btn">å¼€å§‹å…¨æ™¯ç›‘ç£</button>
    </div>

    <div id="report-panel">
        <h3 style="color:white; margin:0;">ä¸“æ³¨è¯„åˆ†</h3>
        <div class="score" id="final-score">0</div>
        <div class="row"><span>â±ï¸ æ—¶é•¿</span><span id="r-time">0åˆ†</span></div>
        <div class="row"><span>ğŸ‘€ äººè„¸è¿è§„</span><span id="r-face">0æ¬¡</span></div>
        <div class="row"><span>ğŸ® å±å¹•æ‘¸é±¼</span><span id="r-screen">0æ¬¡</span></div>
        <button onclick="location.reload()" style="margin-top:20px; background:#444; color:white; width:100%;">é‡æ–°å¼€å§‹</button>
    </div>

    <script type="module">
        import { FilesetResolver, FaceLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

        const CONFIG = {
            PASSWORD: "8888",
            checkInterval: 1000, 
            threshold: { angle: 0.28, roll: 20 },
            // å±å¹•æ´»è·ƒåº¦é˜ˆå€¼ (0-255)ï¼Œè¶Šé«˜è¶Šä¸çµæ•
            screenDiffThreshold: 15, 
            // åˆ¤å®šä¸ºç©æ¸¸æˆçš„æŒç»­é—ªçƒç§’æ•°
            gamingDuration: 8
        };

        const SPEECH = {
            start: "å…¨æ™¯ç›‘ç£å¯åŠ¨ã€‚è¯·çœ‹ä¹¦æˆ–çœ‹å±å¹•ã€‚",
            distracted: ["è¯·å›æ¥çœ‹ä¹¦ã€‚", "åˆ«ä¸œå¼ è¥¿æœ›ã€‚", "æ³¨æ„åŠ›ï¼"],
            posture: ["åç›´äº†ï¼", "è„Šæ¤è­¦å‘Šï¼"],
            absent: ["äººå‘¢ï¼Ÿ", "å¿«å›æ¥ï¼"],
            gaming: ["å±å¹•é—ªçƒå¤ªå¿«ï¼Œæ˜¯åœ¨ç©æ¸¸æˆå—ï¼Ÿ", "æ£€æµ‹åˆ°å¨±ä¹æ´»åŠ¨ï¼Œè¯·åˆ‡å›å­¦ä¹ ç•Œé¢ã€‚", "åˆ«åˆ·è§†é¢‘äº†ï¼Œå…³æ‰ï¼"],
            stop: "ç›‘ç£ç»“æŸã€‚"
        };

        // çŠ¶æ€
        let faceLandmarker = null;
        let isRunning = false;
        let baseScreenPose = null, baseBookPose = null;
        
        // å±å¹•ç›‘æ§å˜é‡
        let screenStream = null;
        let screenCanvas = document.createElement('canvas');
        let screenCtx = screenCanvas.getContext('2d');
        let lastScreenData = null;
        let highActivityCounter = 0; // è®°å½•è¿ç»­é«˜æ´»è·ƒçš„æ¬¡æ•°

        let stats = { start: 0, faceBad: 0, screenBad: 0, score: 100 };
        let lastCheck = 0;
        let warnCooldown = 0;

        const els = {
            webcam: document.getElementById('webcam'),
            screenVideo: document.getElementById('screen-video'),
            screenBox: document.getElementById('screen-box'),
            startBtn: document.getElementById('start-btn'),
            screenBtn: document.getElementById('screen-btn'),
            stopBtn: document.getElementById('stop-btn'),
            overlay: document.getElementById('countdown-overlay'),
            text: document.getElementById('status-text'),
            ring: document.getElementById('visual-ring')
        };

        // 1. åˆå§‹åŒ–äººè„¸æ¨¡å‹
        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                    outputFaceBlendshapes: true, runningMode: "VIDEO", numFaces: 1
                });
                els.startBtn.innerText = "â‘¡ å¼€å¯æ‘„åƒå¤´æ ¡å‡†";
                els.startBtn.disabled = false;
            } catch(e) { console.error(e); }
        }
        init();

        // 2. å±å¹•å…±äº«é€»è¾‘ (Step 1)
        els.screenBtn.onclick = async () => {
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "always" }, audio: false });
                els.screenVideo.srcObject = screenStream;
                els.screenBox.style.display = 'block';
                els.screenBtn.innerText = "âœ… å±å¹•å·²æ¥å…¥";
                els.screenBtn.style.background = "#2ecc71";
                
                // ç›‘å¬åœæ­¢å…±äº«
                screenStream.getVideoTracks()[0].onended = () => {
                    alert("å±å¹•å…±äº«å·²åœæ­¢ï¼Œç›‘ç£ä¸­æ­¢ï¼");
                    location.reload();
                };
            } catch(e) {
                alert("å¿…é¡»é€‰æ‹©åˆ†äº«å±å¹•æ‰èƒ½è¿›è¡Œç›‘ç£ã€‚");
            }
        };

        // 3. æ‘„åƒå¤´ä¸æ ¡å‡† (Step 2)
        els.startBtn.onclick = async () => {
            if (!screenStream) { alert("è¯·å…ˆç‚¹å‡» â‘  æ¥å…¥å±å¹•ï¼"); return; }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                els.webcam.srcObject = stream;
                els.webcam.onloadeddata = () => els.overlay.style.display = 'flex';
            } catch(e) { alert("æ— æ³•å¼€å¯æ‘„åƒå¤´"); }
        };

        // æ ¡å‡†æŒ‰é’®é€»è¾‘
        const capturePose = () => {
            const now = performance.now();
            const res = faceLandmarker.detectForVideo(els.webcam, now);
            return (res && res.faceLandmarks.length) ? calculatePose(res.faceLandmarks[0]) : null;
        };

        document.getElementById('calib-screen-btn').onclick = function() {
            const p = capturePose();
            if(p) { baseScreenPose = p; this.classList.add('done'); this.innerText="å·²é”å®š (çœ‹å±å¹•) âœ…"; checkReady(); } 
            else alert("æ²¡çœ‹åˆ°è„¸");
        };
        document.getElementById('calib-book-btn').onclick = function() {
            const p = capturePose();
            if(p) { baseBookPose = p; this.classList.add('done'); this.innerText="å·²é”å®š (çœ‹ä¹¦æœ¬) âœ…"; checkReady(); }
            else alert("æ²¡çœ‹åˆ°è„¸");
        };
        function checkReady() { if(baseScreenPose || baseBookPose) document.getElementById('calib-final-btn').classList.add('ready'); }

        // 4. æ­£å¼å¼€å§‹
        document.getElementById('calib-final-btn').onclick = () => {
            els.overlay.style.display = 'none';
            els.startBtn.style.display = 'none';
            els.screenBtn.style.display = 'none';
            els.stopBtn.style.display = 'block';
            
            stats.start = Date.now();
            isRunning = true;
            updateStatus("studying", "ğŸ“–", "å…¨æ™¯ç›‘ç£ä¸­...");
            speak(SPEECH.start);
            loop();
        };

        // 5. æ ¸å¿ƒæ£€æµ‹å¾ªç¯
        function loop() {
            if (!isRunning) return;
            const now = Date.now();
            if (now - lastCheck > CONFIG.checkInterval) {
                
                // A. äººè„¸æ£€æµ‹
                if (els.webcam.currentTime > 0) {
                    const res = faceLandmarker.detectForVideo(els.webcam, performance.now());
                    analyzeFace(res);
                }

                // B. å±å¹•æ£€æµ‹
                analyzeScreen();

                lastCheck = now;
            }
            requestAnimationFrame(loop);
        }

        // --- å±å¹•åˆ†æç®—æ³• ---
        function analyzeScreen() {
            // 1. å°†å±å¹•ç”»é¢ç”»åˆ° Canvas (ç¼©å°å¤„ç†ï¼Œä¸ºäº†æ€§èƒ½ 100x100 è¶³å¤Ÿ)
            const w = 100, h = 80; 
            screenCanvas.width = w; screenCanvas.height = h;
            screenCtx.drawImage(els.screenVideo, 0, 0, w, h);
            
            // 2. è·å–åƒç´ æ•°æ®
            const frame = screenCtx.getImageData(0, 0, w, h);
            const data = frame.data;
            
            // 3. å¦‚æœæ˜¯ç¬¬ä¸€å¸§ï¼Œå­˜ä¸‹æ¥
            if (!lastScreenData) {
                lastScreenData = data;
                return;
            }

            // 4. è®¡ç®—å·®å¼‚ (Diff)
            let diffScore = 0;
            // æ­¥é•¿å– 4 (RGBA)ï¼Œæ¯éš”å‡ ä¸ªåƒç´ æŠ½æ ·æ£€æµ‹ï¼Œçœæ€§èƒ½
            for (let i = 0; i < data.length; i += 16) {
                const rDiff = Math.abs(data[i] - lastScreenData[i]);
                const gDiff = Math.abs(data[i+1] - lastScreenData[i+1]);
                const bDiff = Math.abs(data[i+2] - lastScreenData[i+2]);
                if (rDiff + gDiff + bDiff > 100) diffScore++;
            }

            // æ›´æ–°æ—§å¸§
            lastScreenData = data;

            // 5. åˆ¤å®šé€»è¾‘
            // diffScore è¶Šé«˜ï¼Œè¯´æ˜ç”»é¢å˜åŒ–è¶Šå‰§çƒˆ
            // console.log("Screen Activity:", diffScore); 

            if (diffScore > 300) { // é˜ˆå€¼ï¼šæ ¹æ® 100x80 çš„ç”»å¸ƒï¼Œ300ä¸ªç‚¹å‰§çƒˆå˜åŒ–ç®—æ´»è·ƒ
                highActivityCounter++;
            } else {
                highActivityCounter = Math.max(0, highActivityCounter - 1); // ç¼“æ…¢å†·å´
            }

            if (highActivityCounter > CONFIG.gamingDuration) {
                handleWarn("gaming", "ğŸ® ç¦æ­¢æ‘¸é±¼ï¼");
                stats.screenBad++;
                // æŠ¥è­¦åæ¸…ç©ºè®¡æ•°ï¼Œé˜²æ­¢ä¸€ç›´å«
                highActivityCounter = 0; 
            }
        }

        // --- äººè„¸åˆ†æç®—æ³• (ç®€åŒ–ç‰ˆ) ---
        function analyzeFace(results) {
            if (!results.faceLandmarks.length) {
                handleWarn("absent", "ğŸ‘» äººå‘¢ï¼Ÿ");
                stats.faceBad++;
                return;
            }
            const p = calculatePose(results.faceLandmarks[0]);
            let ok = false;
            if (baseScreenPose && isClose(p, baseScreenPose)) ok = true;
            if (baseBookPose && isClose(p, baseBookPose)) ok = true;

            if (!ok) {
                const diffRoll = baseScreenPose ? Math.abs(p.roll - baseScreenPose.roll) : 0;
                if (diffRoll > CONFIG.threshold.roll) handleWarn("posture", "ğŸ¦´ åç›´ï¼");
                else handleWarn("distracted", "ğŸ‘€ åˆ«ä¹±çœ‹");
                stats.faceBad++;
            } else {
                updateStatus("studying", "ğŸ“–", "å­¦ä¹ ä¸­...");
            }
        }

        function calculatePose(lm) {
            const nose=lm[1], left=lm[33], right=lm[263];
            const midX=(left.x+right.x)/2, eyeY=(left.y+right.y)/2;
            return {
                yaw: nose.x - midX,
                pitch: nose.y - eyeY,
                roll: Math.atan2(right.y-left.y, right.x-left.x)*180/Math.PI
            };
        }

        function isClose(curr, base) {
            return Math.abs(curr.yaw-base.yaw)<CONFIG.threshold.angle && 
                   Math.abs(curr.pitch-base.pitch)<CONFIG.threshold.angle &&
                   Math.abs(curr.roll-base.roll)<CONFIG.threshold.roll;
        }

        // --- å…¬å…± ---
        function handleWarn(type, txt) {
            updateStatus("warning", txt.substring(0,2), txt);
            if(Date.now() > warnCooldown) {
                speak(pick(SPEECH[type]));
                warnCooldown = Date.now() + 5000;
            }
        }

        function updateStatus(cls, icon, txt) {
            document.body.className = cls;
            els.text.innerText = txt;
            document.getElementById('status-icon').innerText = icon;
        }

        els.stopBtn.onclick = () => {
            if (prompt("å¯†ç ï¼š") === CONFIG.PASSWORD) {
                isRunning = false;
                if(screenStream) screenStream.getTracks().forEach(t=>t.stop());
                if(els.webcam.srcObject) els.webcam.srcObject.getTracks().forEach(t=>t.stop());
                showReport();
            } else speak("å¯†ç é”™è¯¯");
        };

        function showReport() {
            document.getElementById('report-panel').style.display = 'flex';
            document.getElementById('r-time').innerText = Math.floor((Date.now()-stats.start)/60000)+"åˆ†";
            document.getElementById('r-face').innerText = stats.faceBad;
            document.getElementById('r-screen').innerText = stats.screenBad;
            let s = 100 - (stats.faceBad*2 + stats.screenBad*5);
            document.getElementById('final-score').innerText = Math.max(0, s);
            speak(SPEECH.stop);
        }

        const synth = window.speechSynthesis;
        function speak(text) {
            if(!synth) return;
            synth.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = "zh-CN"; u.rate = 1.2;
            synth.speak(u);
        }
        function pick(arr) { return arr[Math.floor(Math.random()*arr.length)]; }
        document.body.addEventListener('click', ()=>{if(synth)synth.speak(new SpeechSynthesisUtterance(" "))}, {once:true});

    </script>
</body>
</html>
