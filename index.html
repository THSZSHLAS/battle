<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>æ±¤è‡£å­¦ä¹ ç›‘ç£_5.7</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body { margin: 0; padding: 0; background-color: #1a1a1a; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: white; overflow: hidden; user-select: none; }

        /* === è§†è§‰åœ†ç¯ === */
        #visual-ring { width: 200px; height: 200px; border: 8px solid #444; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.4s; position: relative; background: rgba(0,0,0,0.2); z-index: 5; }
        
        /* çŠ¶æ€æ ·å¼ */
        body.studying #visual-ring { border-color: #2ecc71; box-shadow: 0 0 40px rgba(46, 204, 113, 0.4); animation: breathe 3s infinite ease-in-out; }
        /* ç¼“å†²çŠ¶æ€ï¼ˆé»„è‰²ï¼‰ï¼šç»™3ç§’æœºä¼š */
        body.pending #visual-ring { border-color: #f1c40f; box-shadow: 0 0 30px rgba(241, 196, 15, 0.4); transform: scale(1.02); }
        /* è­¦å‘ŠçŠ¶æ€ï¼ˆçº¢è‰²ï¼‰ï¼šçœŸæŠ¥è­¦ */
        body.warning #visual-ring { border-color: #e74c3c; background-color: rgba(231, 76, 60, 0.15); box-shadow: 0 0 60px rgba(231, 76, 60, 0.7); transform: scale(1.1); animation: pulse-red 0.5s infinite; }
        
        .icon { font-size: 60px; }
        #status-text { margin-top: 30px; font-size: 20px; font-weight: 400; opacity: 0.9; text-align: center; height: 30px; z-index: 5; }

        /* === ç›‘æ§çª—å£ === */
        .cam-box { position: absolute; top: 20px; right: 20px; width: 200px; height: 150px; border: 2px solid #555; border-radius: 10px; overflow: hidden; z-index: 10; background: #000; }
        video#webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.9; }

        .screen-box { position: absolute; top: 20px; left: 20px; width: 240px; height: 150px; border: 2px solid #555; border-radius: 10px; overflow: hidden; z-index: 10; background: #000; display: flex; flex-direction: column; }
        video#screen-video { width: 100%; height: 130px; object-fit: contain; opacity: 1; }
        
        #activity-bar-bg { width: 100%; height: 20px; background: #222; position: relative; }
        #activity-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #2ecc71, #f1c40f, #e74c3c); transition: width 0.2s; }
        #activity-text { position: absolute; top: 0; left: 5px; font-size: 10px; line-height: 20px; color: #fff; text-shadow: 1px 1px 2px black; }

        /* åº•éƒ¨æ§åˆ¶ */
        #controls { position: fixed; bottom: 40px; display: flex; gap: 15px; align-items: center; padding: 12px 25px; background: rgba(30,30,30,0.9); border-radius: 40px; z-index: 50; }
        button, select { padding: 10px 20px; border-radius: 20px; border: none; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button:active { transform: scale(0.95); }
        #screen-btn { background: #3498db; color: #fff; }
        #start-btn { background: #2ecc71; color: #fff; }
        #stop-btn { background: #ff4757; color: #fff; display: none; }
        #break-btn { background: #f1c40f; color: #000; display: none; }
        #mode-select { background: #444; color: #fff; }

        /* é®ç½©ä¸æŠ¥å‘Š */
        #countdown-overlay, #report-panel { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; display: none; align-items: center; justify-content: center; flex-direction: column; background: rgba(0,0,0,0.95); }
        
        #report-panel { background: #1e1e1e; width: 90%; height: 90%; top: 50%; left: 50%; transform: translate(-50%, -50%); border-radius: 20px; padding: 20px; border: 1px solid #444; display: none; flex-direction: column; overflow: hidden; box-sizing: border-box; }
        .report-header { text-align: center; margin-bottom: 10px; flex-shrink: 0; }
        .score { font-size: 50px; font-weight: 800; color: #2ecc71; margin: 5px 0; }
        
        .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: right; }
        .stat-item { font-size: 12px; color: #ccc; }
        .stat-item b { color: #fff; font-size: 14px; margin-left: 5px; }

        #evidence-title { width: 100%; text-align: left; font-size: 14px; color: #aaa; margin-bottom: 10px; }
        #evidence-gallery {
            flex: 1; width: 100%; overflow-y: auto; 
            display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
            gap: 15px; padding: 10px; background: #111; border-radius: 10px; border: 1px solid #333;
            align-content: start;
        }
        
        .evidence-card { 
            position: relative; border-radius: 8px; overflow: hidden; border: 1px solid #444; 
            background: black; display: flex; align-items: center; justify-content: center;
            min-height: 120px;
        }
        .evidence-card img { width: 100%; height: auto; display: block; }
        .evidence-meta {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(0,0,0, 0.7); color: white;
            font-size: 11px; padding: 5px;
            display: flex; justify-content: space-between;
        }
        .tag-gaming { color: #ff4757; font-weight: bold; }
        .tag-face { color: #f1c40f; font-weight: bold; }
        .tag-absent { color: #a29bfe; font-weight: bold; }

        .calib-btn { padding: 15px 30px; margin: 10px; background: #333; color: white; border: 1px solid #555; width: 260px; text-align: left; }
        .calib-btn.done { background: #2ecc71; border-color: #2ecc71; }
        #calib-start-study-btn { background: linear-gradient(135deg, #2ecc71, #27ae60); margin-top: 20px; width: 260px; text-align: center; font-size: 18px; opacity: 0.5; pointer-events: none; }
        #calib-start-study-btn.ready { opacity: 1; pointer-events: auto; }

        @keyframes breathe { 0%,100%{opacity:0.8;transform:scale(1);} 50%{opacity:1;transform:scale(1.05);} }
        @keyframes pulse-red { 0%,100%{box-shadow:0 0 0 rgba(231,76,60,0);} 50%{box-shadow:0 0 40px rgba(231,76,60,0.8);} }
    </style>
</head>
<body>

    <div id="visual-ring"><div class="icon" id="status-icon">ğŸ‘ï¸</div></div>
    <div id="status-text">ç³»ç»Ÿåˆå§‹åŒ–...</div>

    <div class="screen-box" id="screen-box-ui" style="visibility: hidden;">
        <video id="screen-video" autoplay playsinline muted></video>
        <div id="activity-bar-bg">
            <div id="activity-bar"></div>
            <div id="activity-text">å±å¹•çƒ­åº¦: 0%</div>
        </div>
    </div>

    <div class="cam-box">
        <video id="webcam" autoplay playsinline muted></video>
    </div>

    <div id="controls">
        <select id="mode-select">
            <option value="easy">å®½æ¾</option>
            <option value="normal" selected>æ ‡å‡†</option>
            <option value="hard">ä¸¥æ ¼</option>
        </select>
        <button id="screen-btn">â‘  æ¥å…¥å±å¹•</button>
        <button id="start-btn" disabled>â‘¡ æ¥å…¥äººè„¸</button>
        <button id="break-btn">ä¼‘æ¯</button>
        <button id="stop-btn">åœæ­¢</button>
    </div>

    <div id="countdown-overlay">
        <h2 style="color:white; margin-bottom:30px;">å§¿æ€æ ¡å‡†</h2>
        <button id="calib-screen-btn" class="calib-btn">â‘  é”å®šâ€œçœ‹å±å¹•â€å§¿åŠ¿</button>
        <button id="calib-book-btn" class="calib-btn">â‘¡ (å¯é€‰) é”å®šâ€œçœ‹ä¹¦â€å§¿åŠ¿</button>
        <button id="calib-start-study-btn" class="calib-btn">å¼€å§‹ç›‘ç£</button>
    </div>

    <div id="report-panel">
        <div class="report-header">
            <div class="score-box">
                <div class="score" id="final-score">0</div>
            </div>
            <div class="stat-grid">
                <div class="stat-item">â±ï¸ æ—¶é•¿<b id="r-time">0åˆ†</b></div>
                <div class="stat-item">ğŸ‘€ åˆ†å¿ƒ<b id="r-distract">0æ¬¡</b></div>
                <div class="stat-item">ğŸ® æ‘¸é±¼<b id="r-screen">0æ¬¡</b></div>
                <div class="stat-item">ğŸ‘» ç¦»å¼€<b id="r-absent">0æ¬¡</b></div>
            </div>
        </div>
        
        <div id="evidence-title">ğŸ“¸ è¿è§„è¯æ®åº“ï¼š</div>
        <div id="evidence-gallery"></div>
        
        <button onclick="location.reload()" style="margin-top:15px; padding:15px; background:#2ecc71; color:white; width:100%; border:none; border-radius:10px; font-weight:bold; cursor:pointer;">å¼€å¯æ–°çš„ä¸€è½®</button>
    </div>

    <script type="module">
        import { FilesetResolver, FaceLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

        const CONFIG = {
            PASSWORD: "8888",
            checkInterval: 1000, 
            
            // ğŸ†• è°ƒæ•´ï¼šæé«˜å®¹å¿åº¦ (æ•°å€¼è¶Šå¤§è¶Šå®½å®¹)
            threshold: { 
                angle: 0.35,  // åŸ 0.28 -> 0.35 (å…è®¸æ›´å¤§è½¬å¤´/æŠ¬å¤´)
                roll: 25      // åŸ 20 -> 25 (å…è®¸æ›´æ­ªä¸€ç‚¹)
            },
            
            durations: { 
                distractedMs: 3000, // èµ°ç¥å®¹å¿ 3ç§’
                absentMs: 0         // ç¦»å¼€ï¼š0ç§’å®¹å¿ (ç«‹é©¬æŠ¥è­¦)
            },
            
            screen: {
                diffThreshold: 5,   
                heatUp: 10, coolDown: 5, triggerHeat: 160, maxHeat: 200        
            },
            score: { base: 60, focusPerSec: 0.015, distractPen: 1.5, screenPen: 5, absentPen: 3 }
        };

        const SPEECH = {
            start: "ç›‘ç£å¯åŠ¨ã€‚",
            distracted: ["è¯·å›æ¥çœ‹ä¹¦ã€‚", "åˆ«ä¹±çœ‹ã€‚", "æ³¨æ„åŠ›ã€‚"],
            posture: ["åç›´ã€‚", "è…°èƒŒæŒºç›´ã€‚"],
            absent: ["äººå‘¢ï¼Ÿ", "å¿«å›æ¥ã€‚"],
            gaming: ["æ£€æµ‹åˆ°å¨±ä¹è¡Œä¸ºï¼Œå·²è®°å½•è¯æ®ã€‚", "åˆ«æ‘¸é±¼äº†ï¼"],
            stop: "ç›‘ç£ç»“æŸã€‚"
        };

        let faceLandmarker = null, isRunning = false, currentState = "IDLE";
        let lastVideoTime = -1, lastCheck = 0, warnCooldown = 0;
        let baseScreenPose = null, baseBookPose = null;
        
        // è®¡æ—¶å™¨åˆ†å¼€
        let awayStartTime = null; // èµ°ç¥è®¡æ—¶å™¨ (3ç§’ç¼“å†²)
        
        let screenStream = null;
        let screenCanvas = document.createElement('canvas');
        let screenCtx = screenCanvas.getContext('2d');
        let lastScreenData = null, screenHeat = 0;

        let evidenceList = []; 
        let stats = { start: 0, distractCount: 0, postureCount: 0, absentCount: 0, screenCount: 0, score: CONFIG.score.base };

        const els = {
            webcam: document.getElementById('webcam'),
            screenVideo: document.getElementById('screen-video'),
            screenBoxUI: document.getElementById('screen-box-ui'),
            startBtn: document.getElementById('start-btn'),
            screenBtn: document.getElementById('screen-btn'),
            stopBtn: document.getElementById('stop-btn'),
            breakBtn: document.getElementById('break-btn'),
            text: document.getElementById('status-text'),
            icon: document.getElementById('status-icon'),
            modeSelect: document.getElementById('mode-select'),
            overlay: document.getElementById('countdown-overlay'),
            report: document.getElementById('report-panel'),
            actBar: document.getElementById('activity-bar'),
            actText: document.getElementById('activity-text'),
            gallery: document.getElementById('evidence-gallery')
        };

        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task", delegate: "GPU" },
                    outputFaceBlendshapes: true, runningMode: "VIDEO", numFaces: 1
                });
                els.startBtn.innerText = "â‘¡ æ¥å…¥äººè„¸"; els.startBtn.disabled = false;
            } catch(e) { console.error(e); }
        }
        init();

        els.screenBtn.onclick = async () => {
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "always" }, audio: false });
                els.screenVideo.srcObject = screenStream;
                els.screenBoxUI.style.visibility = 'visible';
                els.screenBtn.innerText = "âœ… å±å¹•å·²æ¥å…¥";
                els.screenBtn.style.background = "#2ecc71";
                screenStream.getVideoTracks()[0].onended = () => location.reload();
            } catch(e) { alert("å¿…é¡»æ¥å…¥å±å¹•æ‰èƒ½å¼€å§‹ã€‚è¯·é€‰æ‹©â€˜æ•´ä¸ªå±å¹•â€™ã€‚"); }
        };

        els.startBtn.onclick = async () => {
            if (!faceLandmarker) return;
            if (!screenStream) { alert("è¯·å…ˆæ¥å…¥å±å¹•ï¼"); return; }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                els.webcam.srcObject = stream;
                els.webcam.onloadeddata = () => els.overlay.style.display = 'flex';
            } catch(e) { alert("æ‘„åƒå¤´æ‰“å¼€å¤±è´¥"); }
        };

        const capturePose = () => {
            const now = performance.now();
            const res = faceLandmarker.detectForVideo(els.webcam, now);
            return (res && res.faceLandmarks.length) ? calculatePose(res.faceLandmarks[0]) : null;
        };
        document.getElementById('calib-screen-btn').onclick = function() {
            const p = capturePose();
            if(p) { baseScreenPose = p; this.classList.add('done'); this.innerText="å·²é”å®š (çœ‹å±å¹•) âœ…"; checkReady(); } else alert("æ²¡çœ‹åˆ°è„¸");
        };
        document.getElementById('calib-book-btn').onclick = function() {
            const p = capturePose();
            if(p) { baseBookPose = p; this.classList.add('done'); this.innerText="å·²é”å®š (çœ‹ä¹¦æœ¬) âœ…"; checkReady(); } else alert("æ²¡çœ‹åˆ°è„¸");
        };
        function checkReady() { if(baseScreenPose || baseBookPose) document.getElementById('calib-start-study-btn').classList.add('ready'); }

        document.getElementById('calib-start-study-btn').onclick = () => {
            els.overlay.style.display = 'none';
            els.startBtn.style.display = 'none';
            els.screenBtn.style.display = 'none';
            els.modeSelect.style.display = 'none';
            els.breakBtn.style.display = 'block';
            els.stopBtn.style.display = 'block';
            
            applyMode(els.modeSelect.value);
            stats.start = Date.now();
            isRunning = true;
            updateStatus("studying", "ğŸ“–", "å…¨æ™¯ç›‘ç£ä¸­...");
            speak(SPEECH.start);
            loop();
        };

        function loop() {
            if (!isRunning) return;
            if (currentState === "BREAK") { requestAnimationFrame(loop); return; }

            const now = Date.now();
            if (now - lastCheck > CONFIG.checkInterval) {
                if(screenStream) analyzeScreen();
                if (els.webcam.currentTime > 0) {
                    const res = faceLandmarker.detectForVideo(els.webcam, performance.now());
                    analyzeFace(res);
                }
                lastCheck = now;
            }
            requestAnimationFrame(loop);
        }

        // --- å…¨å±é«˜æ¸…æˆªå›¾ ---
        function captureEvidence(type) {
            if (evidenceList.length > 20) return;

            let sourceVideo = els.webcam;
            if (type === "GAMING") sourceVideo = els.screenVideo;

            // å®‰å…¨æ£€æŸ¥
            if (sourceVideo.readyState < 2) return;

            const canvas = document.createElement('canvas');
            // è·å–è§†é¢‘æºçœŸå®å°ºå¯¸
            const vw = sourceVideo.videoWidth;
            const vh = sourceVideo.videoHeight;
            
            // ä¸ºäº†èŠ‚çœå†…å­˜ï¼ŒæŒ‰ 50% æ¯”ä¾‹æˆªå–ï¼Œä½†åœ¨æŠ¥å‘Šé‡Œå±•ç¤ºå…¨å›¾
            canvas.width = vw * 0.5;
            canvas.height = vh * 0.5;
            const ctx = canvas.getContext('2d');
            
            if (type === "GAMING") {
                ctx.drawImage(sourceVideo, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(sourceVideo, 0, 0, canvas.width, canvas.height);
            }
            
            const imgUrl = canvas.toDataURL('image/jpeg', 0.6);
            const timeStr = new Date().toLocaleTimeString();
            evidenceList.push({ type: type, time: timeStr, img: imgUrl });
        }

        function analyzeScreen() {
            const w = 128, h = 72;
            screenCanvas.width = w; screenCanvas.height = h;
            screenCtx.drawImage(els.screenVideo, 0, 0, w, h);
            const frame = screenCtx.getImageData(0, 0, w, h);
            const data = frame.data;

            if (!lastScreenData) { lastScreenData = data; return; }

            let diffCount = 0;
            for (let i = 0; i < data.length; i += 4) {
                const diff = Math.abs(data[i] - lastScreenData[i]) + Math.abs(data[i+1] - lastScreenData[i+1]) + Math.abs(data[i+2] - lastScreenData[i+2]);
                if (diff > 50) diffCount++;
            }
            lastScreenData = data;

            if (diffCount > CONFIG.screen.diffThreshold) screenHeat += CONFIG.screen.heatUp;
            else screenHeat -= CONFIG.screen.coolDown;
            
            screenHeat = Math.max(0, Math.min(CONFIG.screen.maxHeat, screenHeat));

            const percent = Math.round((screenHeat / CONFIG.screen.maxHeat) * 100);
            els.actBar.style.width = percent + "%";
            els.actText.innerText = "å±å¹•çƒ­åº¦: " + percent + "%";
            
            if (percent > 40) els.actBar.style.background = "linear-gradient(90deg, #f1c40f, #e74c3c)";
            else els.actBar.style.background = "linear-gradient(90deg, #2ecc71, #f1c40f)";

            if (screenHeat > CONFIG.screen.triggerHeat) {
                if (currentState !== "GAMING") {
                    handleWarn("gaming", "ğŸ® å±å¹•åŠ¨é™å¤ªå¤§ï¼");
                    captureEvidence("GAMING"); 
                    currentState = "GAMING";
                    stats.screenCount++;
                    stats.score -= CONFIG.score.screenPen;
                }
            } else if (currentState === "GAMING" && screenHeat < (CONFIG.screen.triggerHeat * 0.5)) {
                currentState = "FOCUSED";
                updateStatus("studying", "ğŸ“–", "å­¦ä¹ ä¸­...");
            }
        }

        function analyzeFace(results) {
            if(currentState === "GAMING") return;

            // 1. æ¶ˆå¤±æ£€æµ‹ (ç«‹å³è§¦å‘ï¼Œä¸ç¼“å†²)
            if (!results.faceLandmarks.length) {
                if(currentState !== "ABSENT") { 
                    handleWarn("absent", "ğŸ‘» äººå‘¢ï¼Ÿ");
                    captureEvidence("ABSENT"); 
                    stats.absentCount++; stats.score -= CONFIG.score.absentPen; currentState="ABSENT"; 
                }
                return;
            }
            
            // æœ‰äººè„¸ï¼Œé‡ç½®â€œæ¶ˆå¤±è®¡æ—¶â€
            // æ³¨æ„ï¼šèµ°ç¥è®¡æ—¶ awayStartTime æ˜¯å•ç‹¬çš„ï¼Œä¸èƒ½åœ¨è¿™é‡Œé‡ç½®

            const lm = results.faceLandmarks[0];
            const p = calculatePose(lm);
            let ok = false;
            if (baseScreenPose && isClose(p, baseScreenPose)) ok = true;
            if (baseBookPose && isClose(p, baseBookPose)) ok = true;

            if (!ok) {
                // å§¿åŠ¿ä¸å¯¹ï¼Œå¼€å§‹ç¼“å†²è®¡æ—¶
                if(!awayStartTime) awayStartTime = Date.now();
                const elapsed = Date.now() - awayStartTime;

                if(elapsed > CONFIG.durations.distractedMs) {
                    // è¶…è¿‡3ç§’ï¼ŒçœŸçš„èµ°ç¥äº†
                    if (currentState !== "DISTRACTED") {
                        const diffRoll = baseScreenPose ? Math.abs(p.roll - baseScreenPose.roll) : 0;
                        let type = diffRoll > CONFIG.threshold.roll ? "posture" : "distracted";
                        let txt = type === "posture" ? "ğŸ¦´ åç›´ï¼" : "ğŸ‘€ åˆ«ä¹±çœ‹";
                        
                        handleWarn(type, txt);
                        captureEvidence(type === "posture" ? "POSTURE" : "DISTRACTED"); 
                        
                        if(type==="distracted") stats.distractCount++; else stats.postureCount++;
                        stats.score -= (type==="distracted"?CONFIG.score.distractPen:CONFIG.score.posturePen);
                        currentState = "DISTRACTED";
                    }
                } else {
                    // ç¼“å†²æœŸï¼Œç»™é»„è‰²è­¦å‘Š
                    document.body.className = "pending";
                    els.text.innerText = "âš ï¸ è°ƒæ•´ä¸­...";
                }
            } else {
                // å§¿åŠ¿æ­£ç¡®ï¼Œé‡ç½®èµ°ç¥è®¡æ—¶
                awayStartTime = null;
                
                if(currentState !== "FOCUSED") {
                    currentState = "FOCUSED";
                    updateStatus("studying", "ğŸ“–", "å­¦ä¹ ä¸­...");
                    stats.score += CONFIG.score.focusPerSec;
                }
            }
            if(stats.score < 0) stats.score = 0;
            if(stats.score > 100) stats.score = 100;
        }

        function calculatePose(lm) {
            const nose=lm[1], left=lm[33], right=lm[263];
            const midX=(left.x+right.x)/2, eyeY=(left.y+right.y)/2;
            return {
                yaw: nose.x - midX,
                pitch: nose.y - eyeY,
                roll: Math.atan2(right.y-left.y, right.x-left.x)*180/Math.PI
            };
        }
        function isClose(curr, base) {
            return Math.abs(curr.yaw-base.yaw)<CONFIG.threshold.angle && 
                   Math.abs(curr.pitch-base.pitch)<CONFIG.threshold.angle &&
                   Math.abs(curr.roll-base.roll)<CONFIG.threshold.roll;
        }
        function handleWarn(type, txt) {
            updateStatus("warning", txt.substring(0,2), txt);
            if(Date.now() > warnCooldown) {
                speak(pick(SPEECH[type]));
                warnCooldown = Date.now() + 5000;
            }
        }
        function updateStatus(cls, icon, txt) {
            document.body.className = cls;
            els.text.innerText = txt;
            els.icon.innerText = icon;
        }
        function applyMode(mode) {
            if(mode === "hard") { CONFIG.threshold.angle=0.20; CONFIG.screen.triggerHeat=120; }
            else if(mode==="easy") { CONFIG.threshold.angle=0.45; CONFIG.screen.triggerHeat=180; }
        }

        els.stopBtn.onclick = () => {
            if (prompt("å¯†ç ï¼š") === CONFIG.PASSWORD) {
                isRunning = false;
                if(screenStream) screenStream.getTracks().forEach(t=>t.stop());
                if(els.webcam.srcObject) els.webcam.srcObject.getTracks().forEach(t=>t.stop());
                els.report.style.display = 'flex';
                setTimeout(() => els.report.classList.add('show'), 10);
                showReport();
            } else speak("å¯†ç é”™è¯¯");
        };

        function showReport() {
            document.getElementById('r-time').innerText = Math.floor((Date.now()-stats.start)/60000)+"åˆ†";
            document.getElementById('r-distract').innerText = stats.distractCount;
            document.getElementById('r-screen').innerText = stats.screenCount;
            document.getElementById('r-absent').innerText = stats.absentCount;
            let s = Math.round(stats.score);
            document.getElementById('final-score').innerText = Math.max(0, s);

            els.gallery.innerHTML = "";
            if (evidenceList.length === 0) {
                els.gallery.innerHTML = "<div style='color:#666; width:100%; text-align:center;'>è¡¨ç°å®Œç¾ï¼Œæ— è¿è§„è®°å½• ğŸ‘</div>";
            } else {
                evidenceList.forEach(item => {
                    const card = document.createElement('div');
                    card.className = "evidence-card";
                    const tagText = { "GAMING": "ğŸ® æ‘¸é±¼", "ABSENT": "ğŸ‘» ç¦»å¼€", "DISTRACTED": "ğŸ‘€ åˆ†å¿ƒ", "POSTURE": "ğŸ¦´ åå§¿" }[item.type] || item.type;
                    const tagClass = item.type === 'GAMING' ? 'tag-gaming' : (item.type==='ABSENT'?'tag-absent':'tag-face');
                    card.innerHTML = `<img src="${item.img}"><div class="evidence-meta"><span class="${tagClass}">${tagText}</span><span>${item.time}</span></div>`;
                    els.gallery.appendChild(card);
                });
            }
            speak(SPEECH.stop);
        }

        els.breakBtn.onclick = () => {
            if (currentState === "BREAK") {
                currentState = "FOCUSED"; awayStartTime = null; screenHeat = 0;
                els.breakBtn.innerText = "ä¼‘æ¯"; els.stopBtn.style.display = "block";
                updateStatus("studying", "ğŸ“–", "æ¬¢è¿å›æ¥"); speak("ä¼‘æ¯ç»“æŸ");
            } else {
                currentState = "BREAK";
                els.breakBtn.innerText = "ç»“æŸä¼‘æ¯"; els.stopBtn.style.display = "none";
                updateStatus("break", "â˜•", "ä¼‘æ¯ä¸­..."); speak("ä¼‘æ¯å¼€å§‹");
            }
        };

        const synth = window.speechSynthesis;
        function speak(text) {
            if(!synth) return;
            synth.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = "zh-CN"; u.rate = 1.2;
            synth.speak(u);
        }
        function pick(arr) { return arr[Math.floor(Math.random()*arr.length)]; }
        document.body.addEventListener('click', ()=>{if(synth)synth.speak(new SpeechSynthesisUtterance(" "))}, {once:true});

    </script>
</body>
</html>
